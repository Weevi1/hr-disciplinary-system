/**
 * API Layer - Single point of access for all data operations
 * 
 * Benefits:
 * - Decouples components from direct service calls
 * - Consistent error handling across the app
 * - Easy to mock for testing
 * - Clear API surface for the entire application
 * - Future-proof for potential backend changes
 */

import { DataService } from '../services/DataService';
import { WarningService } from '../services/WarningService';
// import * as UniversalCategories from '../services/UniversalCategories'; // TODO: Fix import
import type { 
  Warning,
  WarningLevel,
  EnhancedWarningFormData,
  EscalationRecommendation 
} from '../types/warning';
import type { Employee } from '../types';

// ============================================
// ERROR HANDLING
// ============================================

class APIError extends Error {
  constructor(message: string, public code: string, public originalError?: unknown) {
    super(message);
    this.name = 'APIError';
  }
}

const handleError = (operation: string, error: unknown): never => {
  console.error(`API Error in ${operation}:`, error);
  
  if (error instanceof Error) {
    throw new APIError(`${operation} failed: ${error.message}`, 'OPERATION_FAILED', error);
  }
  
  throw new APIError(`${operation} failed with unknown error`, 'UNKNOWN_ERROR', error);
};

// ============================================
// WARNINGS API
// ============================================

export const warnings = {
  /**
   * Get all warnings with optional filters
   */
  async getAll(organizationId: string, filters?: { 
    status?: string;
    employeeId?: string;
    level?: WarningLevel;
  }): Promise<Warning[]> {
    try {
      return await DataService.getWarningsByOrganization(organizationId);
    } catch (error) {
      handleError('warnings.getAll', error);
    }
  },

  /**
   * Get warning by ID
   */
  async getById(warningId: string): Promise<Warning | null> {
    try {
      return await WarningService.getWarningById(warningId);
    } catch (error) {
      handleError('warnings.getById', error);
    }
  },

  /**
   * Create new warning
   */
  async create(warningData: EnhancedWarningFormData): Promise<string> {
    try {
      // Use DataService to save the warning directly
      console.log('ðŸ’¾ Creating warning via DataService:', warningData);
      
      // Transform the enhanced form data to warning format
      const warning: Warning = {
        id: '', // Will be generated by Firestore
        organizationId: warningData.organizationId,
        employeeId: warningData.employeeId,
        categoryId: warningData.categoryId,
        category: warningData.categoryName || 'Unknown',
        categoryName: warningData.categoryName || 'Unknown', // Keep separate field for clarity
        level: warningData.level || 'verbal',
        
        // Employee snapshot data (denormalized for dashboard) - Keep individual fields
        employeeName: warningData.employeeName || 'Unknown',
        employeeLastName: warningData.employeeLastName || 'Employee',
        employeeNumber: warningData.employeeNumber || 'Unknown',
        employeeDepartment: warningData.employeeDepartment || 'Unknown',
        employeePosition: warningData.employeePosition || 'Unknown',
        department: warningData.employeeDepartment || 'Unknown', // Legacy field for compatibility
        position: warningData.employeePosition || 'Unknown', // Legacy field for compatibility
        
        // Incident details
        incidentDate: new Date(warningData.incidentDate),
        incidentTime: warningData.incidentTime,
        incidentLocation: warningData.incidentLocation,
        description: warningData.incidentDescription,
        
        // Administrative
        issueDate: new Date(warningData.issueDate),
        expiryDate: new Date(warningData.expiryDate || Date.now() + (warningData.validityPeriod || 6) * 30 * 24 * 60 * 60 * 1000),
        validityPeriod: warningData.validityPeriod || 6,
        issuedBy: warningData.issuedBy || '',
        issuedByName: warningData.issuedByName || '',
        
        // Status and flags
        isActive: true,
        status: 'draft',
        
        // Optional fields - handle undefined values for Firestore
        ...(warningData.additionalNotes && { additionalNotes: warningData.additionalNotes }),
        ...(warningData.signatures && { signatures: warningData.signatures }),
        
        // MANDATORY: Audio recording is required for every warning
        audioRecording: warningData.audioRecording || {
          status: 'required',
          processingStatus: 'pending',
          error: 'Audio recording not provided'
        },
        deliveryMethod: warningData.deliveryMethod || 'email',
        
        // Audit fields
        createdAt: new Date(),
        updatedAt: new Date()
      };
      
      // Save using WarningService (the original working method)
      const warningId = await WarningService.saveWarning(warning, warningData.organizationId);
      console.log('âœ… Warning created successfully via DataService:', warningId);
      
      return warningId;
    } catch (error) {
      handleError('warnings.create', error);
    }
  },

  /**
   * Update warning
   */
  async update(warningId: string, updates: Partial<Warning>): Promise<void> {
    try {
      // Use DataService for status updates
      if (updates.status && updates.organizationId) {
        await DataService.updateWarningStatus(warningId, updates.status, updates.organizationId);
      } else {
        // TODO: Implement general updates when WarningService is integrated
        console.warn('warnings.update only supports status updates for now');
      }
    } catch (error) {
      handleError('warnings.update', error);
    }
  },

  /**
   * Delete warning (mark as inactive)
   */
  async delete(warningId: string): Promise<void> {
    try {
      // TODO: Implement when WarningService is integrated
      console.warn('warnings.delete not implemented - needs WarningService integration');
    } catch (error) {
      handleError('warnings.delete', error);
    }
  },

  /**
   * Get escalation recommendation for employee
   */
  async getEscalationRecommendation(
    employeeId: string, 
    categoryId: string
  ): Promise<EscalationRecommendation> {
    try {
      // Use WarningService for escalation recommendations
      return await WarningService.getEscalationRecommendation(employeeId, categoryId);
    } catch (error) {
      handleError('warnings.getEscalationRecommendation', error);
    }
  },

  /**
   * Get warning statistics
   */
  async getStats(organizationId: string): Promise<{
    total: number;
    pendingReview: number;
    approved: number;
    byLevel: Record<WarningLevel, number>;
  }> {
    try {
      // Get all warnings and calculate stats
      const allWarnings = await DataService.getWarningsByOrganization(organizationId);
      
      const stats = {
        total: allWarnings.length,
        pendingReview: allWarnings.filter(w => w.status === 'pending_review').length,
        approved: allWarnings.filter(w => w.status === 'approved').length,
        byLevel: {
          counselling: allWarnings.filter(w => w.warningLevel === 'counselling').length,
          written_warning_1: allWarnings.filter(w => w.warningLevel === 'written_warning_1').length,
          written_warning_2: allWarnings.filter(w => w.warningLevel === 'written_warning_2').length,
          final_written_warning: allWarnings.filter(w => w.warningLevel === 'final_written_warning').length,
          dismissal: allWarnings.filter(w => w.warningLevel === 'dismissal').length
        } as Record<WarningLevel, number>
      };
      
      return stats;
    } catch (error) {
      handleError('warnings.getStats', error);
    }
  }
};

// ============================================
// EMPLOYEES API
// ============================================

export const employees = {
  /**
   * Get all employees for organization
   */
  async getAll(organizationId: string): Promise<Employee[]> {
    try {
      return await DataService.getEmployeesByOrganization(organizationId);
    } catch (error) {
      handleError('employees.getAll', error);
    }
  },

  /**
   * Get employee by ID
   */
  async getById(employeeId: string): Promise<Employee | null> {
    try {
      return await DataService.getEmployee(employeeId);
    } catch (error) {
      handleError('employees.getById', error);
    }
  },

  /**
   * Create new employee
   */
  async create(employeeData: Omit<Employee, 'id'>): Promise<string> {
    try {
      return await DataService.saveEmployee(employeeData, employeeData.organizationId);
    } catch (error) {
      handleError('employees.create', error);
    }
  },

  /**
   * Update employee
   */
  async update(employeeId: string, updates: Partial<Employee>): Promise<void> {
    try {
      const employee = await DataService.getEmployee(employeeId);
      if (!employee) throw new Error('Employee not found');
      const updatedEmployee = { ...employee, ...updates };
      await DataService.saveEmployee(updatedEmployee, employee.organizationId);
    } catch (error) {
      handleError('employees.update', error);
    }
  },

  /**
   * Delete employee (archive)
   */
  async delete(employeeId: string): Promise<void> {
    try {
      const employee = await DataService.getEmployee(employeeId);
      if (!employee) throw new Error('Employee not found');
      await DataService.archiveEmployee(employeeId, employee.organizationId);
    } catch (error) {
      handleError('employees.delete', error);
    }
  },

  /**
   * Bulk create employees (for CSV import)
   */
  async bulkCreate(employeesData: Partial<Employee>[], organizationId: string): Promise<string[]> {
    try {
      return await DataService.bulkCreateEmployees(employeesData, organizationId);
    } catch (error) {
      handleError('employees.bulkCreate', error);
    }
  },

  /**
   * Search employees
   */
  async search(organizationId: string, searchTerm: string): Promise<Employee[]> {
    try {
      const employees = await DataService.getEmployeesByOrganization(organizationId);
      const searchLower = searchTerm.toLowerCase();
      return employees.filter(employee => 
        employee.profile.firstName.toLowerCase().includes(searchLower) ||
        employee.profile.lastName.toLowerCase().includes(searchLower) ||
        employee.profile.employeeNumber.toLowerCase().includes(searchLower) ||
        employee.profile.email.toLowerCase().includes(searchLower)
      );
    } catch (error) {
      handleError('employees.search', error);
    }
  },

  /**
   * Get employees by manager ID
   */
  async getByManager(managerId: string, organizationId: string): Promise<Employee[]> {
    try {
      return await DataService.getEmployeesByManager(managerId, organizationId);
    } catch (error) {
      handleError('employees.getByManager', error);
    }
  }
};

// ============================================
// ORGANIZATIONS API
// ============================================

export const organizations = {
  /**
   * Get organization by ID
   */
  async getById(organizationId: string) {
    try {
      return await DataService.getOrganization(organizationId);
    } catch (error) {
      handleError('organizations.getById', error);
    }
  },

  /**
   * Update organization
   */
  async update(organizationId: string, updates: any) {
    try {
      return await DataService.updateOrganization(organizationId, updates);
    } catch (error) {
      handleError('organizations.update', error);
    }
  },

  /**
   * Get organization categories
   */
  async getCategories(organizationId: string) {
    try {
      return await DataService.getWarningCategories(organizationId);
    } catch (error) {
      handleError('organizations.getCategories', error);
    }
  }
};

// ============================================
// CATEGORIES API
// ============================================

export const categories = {
  /**
   * Get all universal categories
   */
  getUniversal() {
    return []; // TODO: Fix UniversalCategories import
  },

  /**
   * Get category by ID
   */
  getById(categoryId: string) {
    return null; // TODO: Fix UniversalCategories import
  },

  /**
   * Get escalation path for category
   */
  getEscalationPath(categoryId: string) {
    return []; // TODO: Fix UniversalCategories import
  },

  /**
   * Get next escalation level
   */
  getNextLevel(categoryId: string, currentLevel: WarningLevel) {
    return 'verbal'; // TODO: Fix UniversalCategories import
  }
};

// ============================================
// UNIFIED API EXPORT
// ============================================

export const API = {
  warnings,
  employees,
  organizations,
  categories
} as const;

// Default export for convenience
export default API;

// Export error class for error handling in components
export { APIError };