import{L as c,S as o,s as n}from"./dashboard-components-fvKPXzEF.js";import"./react-vendor-DrdoFN08.js";import"./firebase-vendor-Cz3N8Xg7.js";import"./pdf-vendor-Bp5yZ91a.js";import"./ui-vendor-X12rCvv3.js";import"./warning-components-DfE_qdbY.js";class p{static{this.ARCHIVE_TO_DELETION_DAYS=5*365}static getEmployeeLifecycleState(e){const t={status:e.isActive?"active":"archived",canBeDeleted:!1};return!e.isActive&&e.archivedAt&&(t.archivedAt=new Date(e.archivedAt),t.archiveReason=e.archiveReason,t.archivedBy=e.archivedBy,this.getDaysSinceArchived(e.archivedAt)>=this.ARCHIVE_TO_DELETION_DAYS&&(t.status="deletion_eligible",t.deletionEligibleAt=new Date(new Date(e.archivedAt).getTime()+this.ARCHIVE_TO_DELETION_DAYS*24*60*60*1e3),t.canBeDeleted=!0)),t}static async archiveEmployee(e,t,a){try{c.debug(`🗄️ [LIFECYCLE] Archiving employee: ${e}`);const i=await o.getEmployeeById(e,t);if(!i)throw new Error("Employee not found");if(!i.isActive)throw new Error("Employee is already archived");const r={isActive:!1,archivedAt:n.getServerTimestamp(),archiveReason:a.reason,archivedBy:a.archivedBy,updatedAt:n.getServerTimestamp()};await o.updateEmployee(e,t,r),c.success(`✅ [LIFECYCLE] Employee ${e} archived successfully`),a.notifyEmployee&&c.debug(`📧 [LIFECYCLE] Employee notification requested for ${e}`)}catch(i){throw c.error(`❌ [LIFECYCLE] Failed to archive employee ${e}:`,i),i}}static async restoreEmployee(e,t,a){try{c.debug(`🔄 [LIFECYCLE] Restoring employee: ${e}`);const i=await o.getEmployeeById(e,t);if(!i)throw new Error("Employee not found");if(i.isActive)throw new Error("Employee is already active");const r={isActive:!0,restoredAt:n.getServerTimestamp(),restoredBy:a,updatedAt:n.getServerTimestamp(),archivedAt:null,archiveReason:null,archivedBy:null};await o.updateEmployee(e,t,r),c.success(`✅ [LIFECYCLE] Employee ${e} restored successfully`)}catch(i){throw c.error(`❌ [LIFECYCLE] Failed to restore employee ${e}:`,i),i}}static async getEmployeesEligibleForDeletion(e){try{c.debug(`🔍 [LIFECYCLE] Finding deletion-eligible employees for ${e}`);const a=(await o.queryDocuments(e,"employees",[],{pageSize:1e3,orderField:"archivedAt",orderDirection:"asc"})).documents.filter(i=>i.isActive||!i.archivedAt?!1:this.getDaysSinceArchived(i.archivedAt)>=this.ARCHIVE_TO_DELETION_DAYS);return c.debug(`📊 [LIFECYCLE] Found ${a.length} employees eligible for deletion`),a}catch(t){throw c.error("❌ [LIFECYCLE] Failed to get deletion-eligible employees:",t),t}}static async permanentlyDeleteEmployee(e,t,a,i){try{c.warn(`🗑️ [LIFECYCLE] PERMANENT DELETION requested for employee: ${e}`);const r=await o.getEmployeeById(e,t);if(!r)throw new Error("Employee not found");if(!this.getEmployeeLifecycleState(r).canBeDeleted){const E=this.ARCHIVE_TO_DELETION_DAYS-this.getDaysSinceArchived(r.archivedAt);throw new Error(`Employee not eligible for deletion. ${E} days remaining in archive period.`)}const l=`DELETE-${r.profile.employeeNumber}-${a.slice(-4).toUpperCase()}`;if(i!==l)throw new Error(`Invalid confirmation code. Expected: ${l}`);const d={action:"PERMANENT_DELETION",employeeId:e,employeeNumber:r.profile.employeeNumber,employeeName:`${r.profile.firstName} ${r.profile.lastName}`,deletedBy:a,deletedAt:n.getServerTimestamp(),archiveDate:r.archivedAt,daysArchived:this.getDaysSinceArchived(r.archivedAt),reason:"Automatic deletion after 5-year archive period"};await o.createDocument(t,"employee_deletion_audit",d),await o.deleteDocument(t,"employees",e),c.warn(`🗑️ [LIFECYCLE] PERMANENT DELETION completed for employee: ${e}`),c.warn(`📋 [LIFECYCLE] Audit record created for deletion of ${r.profile.employeeNumber}`)}catch(r){throw c.error(`❌ [LIFECYCLE] Failed to permanently delete employee ${e}:`,r),r}}static async getLifecycleStats(e){try{c.debug(`📊 [LIFECYCLE] Calculating lifecycle stats for ${e}`);const t=await o.queryDocuments(e,"employees",[],{pageSize:2e3,orderField:"createdAt",orderDirection:"asc"}),a={active:0,archived:0,deletionEligible:0,totalArchived:0};let i=null,r=0;for(const s of t.documents)if(s.isActive)a.active++;else if(a.archived++,a.totalArchived++,s.archivedAt){const l=this.getDaysSinceArchived(s.archivedAt);l>=this.ARCHIVE_TO_DELETION_DAYS&&a.deletionEligible++,l>r&&(r=l,i={employeeId:s.id,name:`${s.profile.firstName} ${s.profile.lastName}`,archivedDate:new Date(s.archivedAt),daysArchived:l})}return i&&(a.oldestArchived=i),c.success(`📊 [LIFECYCLE] Stats calculated: ${a.active} active, ${a.archived} archived, ${a.deletionEligible} deletion eligible`),a}catch(t){throw c.error("❌ [LIFECYCLE] Failed to calculate lifecycle stats:",t),t}}static async bulkArchiveEmployees(e,t,a){const i={successful:[],failed:[]};c.debug(`🗄️ [LIFECYCLE] Bulk archiving ${e.length} employees`);for(const r of e)try{await this.archiveEmployee(r,t,a),i.successful.push(r)}catch(s){i.failed.push({employeeId:r,error:s instanceof Error?s.message:"Unknown error"})}return c.success(`✅ [LIFECYCLE] Bulk archive complete: ${i.successful.length} successful, ${i.failed.length} failed`),i}static generateDeletionConfirmationCode(e,t){return`DELETE-${e}-${t.slice(-4).toUpperCase()}`}static canArchiveEmployee(e){return e.isActive?e.disciplinaryRecord?.activeWarnings>0?{canArchive:!0,reason:"Employee has active warnings - ensure proper closure before archiving"}:{canArchive:!0}:{canArchive:!1,reason:"Employee is already archived"}}static getDaysSinceArchived(e){const t=new Date(e),i=new Date().getTime()-t.getTime();return Math.floor(i/(1e3*60*60*24))}static getTimeUntilDeletionEligible(e){const t=this.getDaysSinceArchived(e),a=this.ARCHIVE_TO_DELETION_DAYS-t;if(a<=0)return"Eligible for deletion";const i=Math.floor(a/365),r=a%365;return i>0?`${i} year${i!==1?"s":""} and ${r} day${r!==1?"s":""} remaining`:`${r} day${r!==1?"s":""} remaining`}}export{p as EmployeeLifecycleService};
